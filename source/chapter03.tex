% !TeX spellcheck = en_US
\chapter{Methodology}%
This chapter describes the methodologies of general \gls{mas} design. 
The general \gls{mas} is distributed into internal (3.1) and external(3.2) parts,  
with a \gls{mas} for \gls{cda} and \gls{ra} as an internal and \gls{dt} agent as an external system. 
These two systems are decoupled from each other but still under the concept of agent based operation system. 
\section{Internal}
In this section, the design pattern for \gls{mas} is chosen and the tasks of each module within is discussed.
After that, the characteristics of transport layer protocols and application layers protocols are compared. 
Eventually the methodologies of using python WebSocket for \gls{mas} and RESTful API for one to one agent communication are listed in pseudocode. 

\subsection{Overview (conceptual diagram)}

%figure conceptual MAS
\begin{figure}[htb]
\includegraphics[width=\textwidth]{figures/MAS_Conceptual_Diagram.png}
\centering
\caption{Conceptual diagram of MAS\label{fig: MASConceptual}}
\end{figure}

% decribe the conceptual diagram

The figure.\ref{fig: MASConceptual} shows a conceptual diagram of a \gls{mas} based on the \gls{ra} design patterns in Wannagat’s architecture, with the focus on communication between agents, planning and decision making inside each agent. The \gls{cda} here is identical to \gls{ams} of Wanagat, which should also be counted as an agent instead of a management system. The five modules within an agent are: 
\begin{itemize}
\item Planning Module,
\item Control Module,
\item Knowledge Base,
\item Diagnosis Module,
\item Communication Interface.
\end{itemize}

for both Coordinator agent or a \gls{ra}.
Based on these five modules, the task to be executed in an agent should also be categorized into 5 parts. The following table shows some tasks of each module based on the general requirements of a smart factory.



\begin{table}[]
\caption{Wanagat's \gls{ra} design patterns with task related examples.}
\label{tab:designPatterns}
\renewcommand{\arraystretch}{1} 
\setlength{\extrarowheight}{3pt}

\begin{tabular}{|m{0.2\textwidth}|m{0.3\textwidth}|m{0.5\textwidth}|}
\hline
\multicolumn{3}{|c|}{ Wanagat's design patterns} \\ % Header with background color
\hline
Module name& Task &Example \\ 
\hline
\begin{tabular}[c]{@{}p{0.2\textwidth}@{}} Planning Module \end{tabular} & \begin{tabular}[c]{@{}p{0.3\textwidth}@{}} \textbullet\  Task planning \\ \textbullet\ Decision making \\ \textbullet\ Resource allocation \\ \textbullet\ Sequencing \\ \textbullet\ Scheduling\end{tabular} 
& \begin{tabular}[c]{@{}p{0.5\textwidth}@{}} \textbullet\ Break down tasks into smaller executable units\\ \textbullet\ Decide which task should be assigned to which agent \\ \textbullet\ Allocate the agents with specific tasks \\ \textbullet\ Find the task execution sequence \\ \textbullet\ Calculate the execution time for each agent\end{tabular}  \\ 
\hline

\begin{tabular}[c]{@{}p{0.2\textwidth}@{}} Control Module \end{tabular}& \begin{tabular}[c]{@{}p{0.3\textwidth}@{}} \textbullet\ Monitoring \\ \textbullet\ Adaptation \\ \textbullet\ Control and optimization \\ \textbullet\ Resource allocation \\ \textbullet\ Actuation\end{tabular} 
& \begin{tabular}[c]{@{}p{0.5\textwidth}@{}} \textbullet\ Acquisition of robot states\\ \textbullet\ Adapt the plans with
current state, e.g.: emergent stop \\ \textbullet\ Control and optimize the robot’s motion \\ \textbullet\ Allocate the agents with specific tasks \\ \textbullet\ Actuate the robot with outputs\end{tabular}  \\ 
\hline

\begin{tabular}[c]{@{}p{0.2\textwidth}@{}}Knowledge Base \end{tabular} & \begin{tabular}[c]{@{}p{0.3\textwidth}@{}} \textbullet\ \gls{db} \\ \textbullet\ Knowledge representation and reasoning \\ \textbullet\ Learning \\ \textbullet\ Knowledge sharing\end{tabular} 
& \begin{tabular}[c]{@{}p{0.5\textwidth}@{}} \textbullet\ Hierarchical, relational, non-relational and object oriented\\ \textbullet\ Relational ontology \gls{db} system \\ \textbullet\ Agent learns from the existing primitives
and create new executable primitives for customer’s changing
requirements \\ \textbullet\ Unfound primitives
could be retrieved by querying other agents\end{tabular}  \\ 
\hline

\begin{tabular}[c]{@{}p{0.2\textwidth}@{}} Diagnosis Module \end{tabular} & \begin{tabular}[c]{@{}p{0.3\textwidth}@{}} \textbullet\ Fault detection \\ \textbullet\ Fault diagnosis \\ \textbullet\ Root cause analysis and classification \\ \textbullet\ Fault prediction\end{tabular} 
& \begin{tabular}[c]{@{}p{0.5\textwidth}@{}} \textbullet\ Monitor the time-series data to detect anomalies from robot states, e.g.: detect faulty joint values for abortion\\ \textbullet\ More complex analysis to diagnose faulty patterns with mathematical algorithms and models, or AI-based methods \\ \textbullet\ Find the reasons for anomalies and categorize them for patterns recognition \\ \textbullet\ Predict the system faults by learning the classification models\end{tabular}  \\ 
\hline

\begin{tabular}[c]{@{}p{0.2\textwidth}@{}} Communication Interface \end{tabular}& \begin{tabular}[c]{@{}p{0.3\textwidth}@{}} \textbullet\ Message parsing and encoding \\ \textbullet\ Connection establishment and maintenance \\ \textbullet\ Message handling \\ \textbullet\ Data security\end{tabular} 
& \begin{tabular}[c]{@{}p{0.5\textwidth}@{}} \textbullet\ Encode and decode the messages in agent specific data type, or parse the data object to other types, e.g.: json\\ \textbullet\ Ensure the connection with other agents based on system requirements \\ \textbullet\ Filter messages with undesired data type or incomplete messages, and prioritize the incoming messages \\ \textbullet\ Ensure data integrity and confidentiality, by encrypting, decrypting and authenticating messages to avoid cyber attack\end{tabular}  \\ 
\hline

\end{tabular}

\label{tab: designPatternsTable}
\end{table}







\subsection{Prerequisite}
\subsubsection{System Setup}
 
%figure conceptual MAS
\begin{figure}[htbp]
\includegraphics[width=0.8\textwidth]{figures/NamespaceConceptual.png}
\centering
\caption{Conceptual diagram of namespaces creation
\label{fig: NSConceptual}}
\end{figure}

In order to emulate network environments for agent's communication testing and development of the \gls{mas}, the internal packets routing between agents in a single Linux device should be avoided. A common way to visualize the network to do performance testing is to use namespaces for network emulation. The trick is that a process running within a given namespace will see only the network interfaces, including virtual interfaces, forwarding tables, etc., that exist in that namespace. The applications under test should serve as a switch and each packet should be routed through these interfaces. The Figure.\ref{fig: NSConceptual} shows that, each namespace is assigned with a virtual ethernet interface, starting with the name eth, which is configured with an individual IP address. Each time a script gets called, it is running under a namespace with its own IP address. In exercise, if a packet is sent from Namespace 1 to Namespace 3 and then back, it is routed by the switch intead of bridges between namespaces, which are not configured here in order to avoid internal routing.

\subsection{OSI model and comparison between sockets relevant protocol layers}
%figure conceptual MAS
\begin{figure}[htbp]
\includegraphics[width=0.8\textwidth]{figures/OSI.pdf}
\centering
\caption{Conceptual diagram of Namespaces creation\label{fig: OSI}}
\end{figure}

Figure. \ref{fig: OSI} shows the famous OSI-Model with 7 abstraction layers with Transport layer and application layers most relevant to sockets. 
TCP and UDP are typical transport layer protocols and they provide an end-to-end data transport between two devices while the application layer protocols like HTTP or Websocket establish a communication between applications within devices. 
Although the application layer protocols still utilize TCP/UDP sockets to transport stream data, they defined additional "rules" to specify structure, content, and semantics of the messages transport through sockets. 
In the following tables, a comparison between protocols in different layers provide a more straight forward overview of their pro and cons in different contents.


% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage{tabularx}
\subsubsection{Transport layer protocols}


Table \ref{tab: transportlayer} compares the typical transport layer protocols \gls{tcp} and \gls{udp} from different aspects.  
\gls{tcp} provides reliable data transfer while \gls{udp} mainly focuses on transport speed and efficiency without reliability guarantee. 
With the focus on speed and reliability, \gls{udp} on one hand offers a faster packet transfer, while on the other hand produces a network dependent packet loss rate and out-of-order packet sequence, compared to \gls{tcp}. 
Because of the requirement of a reliable real time ordered data transfer with minimum to no packet loss in \gls{mas} communication, TCP is used as the base protocols of the design. 


\begin{table}[htbp]
    \small
    \centering
    \caption{Characteristics of different technologies in transportlayer protocols}
    \label{tab: transportlayer}
    \begin{tabular}{|m{0.2\textwidth}|m{0.3\textwidth}|m{0.3\textwidth}|}
    \hline
    \multicolumn{3}{|c|}{\textbf{Transport layer protocols}}                                                            \\ \hline
    \textbf{Aspect}                         & \textbf{\gls{tcp}}             & \textbf{\gls{udp}}        \\ \hline
    Use cases                      & Web browsing, email, text messaging, and file transfers & Live and real-time data transmission \\ \hline
    Reliability                    & Reliable        & Unreliable \\ \hline
    Stream type                    & Byte stream with no preserved boundaries & Message stream with preserved boundaries \\ \hline
    Connection type                & Connection oriented, three handshake & No connection needed \\ \hline
    Overhead                       & Larger than \gls{udp} & Very low   \\ \hline
    Header size                    & 20-60 bytes     & 8 bytes    \\ \hline
    Sequence                       & Packets arrive in sequence & No sequencing for packets \\ \hline
    Retransmission of lost packets & Yes             & No         \\ \hline
    Speed                          & Slower than \gls{udp}, because of overhead and connection & Relative faster than \gls{tcp} \\ \hline
    State                          & Stateful        & Stateless  \\ \hline
    Flow control                   & Yes             & No         \\ \hline
    \end{tabular}
    \end{table}



\subsubsection{Application layer protocols}


% % Please add the following required packages to your document preamble:

\begin{sidewaystable}[htbp]
    \small
    \caption{Characteristics of different technologies in application layer protocols}
    \label{tab: applicationlayer}
    \centering
    \begin{tabular}{|m{0.13\textwidth}|m{0.2\textwidth}|m{0.2\textwidth}|m{0.2\textwidth}|m{0.2\textwidth}|}
    \hline
    \multicolumn{5}{|c|}{\textbf{Application layer protocols}} \\ \hline
    \textbf{Aspect} & \textbf{HTTP} & \textbf{WebSocket} & \textbf{RESTful API} & \textbf{MQTT} \\ \hline
    Use cases & Web pages, images, videos, World Wide Web, etc & Such as chat applications, live gaming, etc & Web and mobile applications with data management requirement & Usually in IoT with limited bandwidth \\ \hline
    Functionality & Request-response protocol based on TCP, foundation for both RESTful APIs and the initial connection in WebSockets & Bi-directional, real-time communication & Uses standard HTTP methods to perform CRUD (Create, Read, Update, Delete) & Lightweight message transport, runs over TCP \\ \hline
    Security & Use SSL/TLS & ws (unsecured) and wss (secured with SSL/TLS) & Similar to HTTP, can be further secured using various authentication mechanisms like OAuth, JWT & Use TLS, like username/password authentication and optional message-level security \\ \hline
    Message patterns & Request-Response & Full Duplex (send and receive independent) & Request-Response & Publish-Subscribe \\ \hline
    Connection type & No connection needed & Persistent {connection} & No connection needed & Persistent connection \\ \hline
    State & Stateless & Stateful & Stateless & Stateful \\ \hline
    Overhead & Overhead for each request-response cycle, especially for new connections & After the initial handshake (HTTP), data frames are lightweight & Similar to HTTP, dependent on API design & Minimal message overhead \\ \hline
    Realtime capability & Less Capable & Highly Suitable & Variable & Highly Suitable \\ \hline
    Flexibility & Supported in all environments & Supported in most modern web browsers and many backend environments & Similar to HTTP & Highly flexible \\ \hline
    Adaptability to dynamic changes & Relative lower (influenced by stateless nature) & High & Relative lower (influenced by stateless nature) & High \\ \hline
    Capability of handling instability & Less capable, requires a stable connection for each request-response cycle & Less stable if connection disruptions happen frequently & Identical to HTTP & Capable, Ideal for remote locations with limited connectivity \\ \hline
    Scalability & Less scalable, require more infrastructure support & Highly scalable, maintains connections for real-time interactions & similar to HTTP, dependent on API design & Highly scalable based on broker-client message transport \\ \hline
    \end{tabular}
\end{sidewaystable}

There are several protocols in application layers that are considered to be suitable for \gls{mas} communication, each with its own advantages and limits in different aspects according to table \ref{tab: applicationlayer}.
To get a closer look of the Table \ref{tab: applicationlayer},  a horizontal comparisons between different application layer protocols: 

\begin{itemize}
\item \gls{http},
\item WebSocket,
\item RESTful API,
\item and \gls{mqtt},
\end{itemize}
should be performed. In one word, WebSocket is chosen to be the application layer protocols for MAS communication, while \gls{tcp} socket for the \gls{dt} agent design, which will be further discussed in the next chapter. Here are the reasons of the choice of WebSocket: 
\begin{enumerate}
\item Bi-directional, full duplex, real time communication between server and clients, no re-connection needed. Suitable for continuous data transfer.
\item Overhead small after connection establishment to reduce latency(\gls{http}).
\item Stateful, store the information of the client's state under connection.
\item High flexibility, adaptability and scalability
\item Secure with wss.
\end{enumerate}

Figure.\ref{fig: MsgConceptual} shows the differences between bi-directional full duplex and other message patterns like Request-Response and Publish-Subscribe, in the context of data transfer. 
For the \gls{mqtt}, publisher publish (send) a message within a topic to the broker (server), while subscriber subscribes (receive) the message from the broker within the same topic. 
For response, a new topic needed to be started, but there is no guarantee that the original publisher is listening, which is a drawback for send-and-receive patterns of \gls{mas}. 

Relatively, the other three protocols will be considered as more appropriate. 
For instance both HTTP and RESTful API run in request-response mechanism. 
A client posts (sends) messages to the server for the other client will get (receive) from it. 
Whether the GET and POST method are successful or not, a response will be given back. With this mechanism, each time a message is going through the server, a new connection will be established and closed after responses are sent. 
The inconsistent connection will consume more communication time and lead to higher latency. 
The ideal solution for that is the bi-directional and full duplex real time communication mechanism of WebSocket. 
Basically the client sends a message to the server, after processing the data, the server will pass the message to the other client and receive response with the same logic. This allows simultaneous communication in both directions between clients, so that no re-connection in the message transfer cycle is necessary. The consistent server-client connection makes it possible to realize a continuous real time communication between agents. In the next section, a more detailed explanation of WebSocket mechanism for \gls{mas} design will be given.

%figure conceptual application layer protocols
\begin{figure}[htb]
\includegraphics[width=0.8\textwidth]{figures/MessageConceptual.png}
\centering
\caption{Conceptual diagram of MAS\label{fig: MsgConceptual}}
\end{figure}

\subsection{Transport layer protocols versus Application layer protocols}
The reasons of choosing application layer protocols over transport layer protocols for \gls{mas} according to table \ref{tab: transportlayer} and \ref{tab: applicationlayer} are listed as following:
\begin{enumerate}
    \item Semantic-rich message patterns. 
    \item Higher flexibility.
    \item Standardized communication between different agents.
    \item Header with agent relevant information.
    \item Security and authentication.
    \end{enumerate}
However, unlike for \gls{mas} design, the architecture of \gls{dt} agent is more straightforward and the basic \gls{tcp} socket is chosen for the more to one server-client communication. 
The details will be discussed later in section 3.2.

\subsection{Pseudo-Code of MAS workflow in WebSocket python}
In algorithm \ref{alg:CDAPseudoCode} is a piece of pseudocode that reflects the workflow of the \gls{mas} for the \gls{cda}. 
Unlike other \gls{ras}, \gls{cda} has no mechanisms of primitives execution but the ability to do planning and decision making. 
Under the Main, the production tasks are broken down into a set of sequenced primitives and then assigened to each allocated agent through one of the predefinded $send\_and\_receive()$ functions under the messageSender class.
After getting responses from the agents, \gls{cda} should deicide whether to start processing by positive responses or retry the steps by negative responses.  
Once the process starts, the \gls{cda} does nothing but wait for the inform messages from the allocated agents by using one of the $receive\_and\_send()$ functions under the messageReceiver class. 
This allows \gls{cda} to have an overall control among the entire prodution process with the purpose of centralization of the distributed agent systems.  


As for the decentralization of \gls{mas}, the \gls{ra} should be able to react to \gls{cda} and do decision making for its own field level control.  
Which means, \gls{cda} should only be informed about the status of the production process, while the exact processes should be done within \gls{ra} and the material flow should be informed between \gls{ras}. The combination of centralization and decentralization will save the resource power consumed by \gls{cda}, 
while still maintains the management level control and decision making.  
The algorithm \ref{alg:RAPseudoCode} shows the logic of a \gls{ra}. At the beginning, \gls{ra} waits for the connection and capability check from \gls{cda}, after that first agent in the list of $sequenced\_agent$ will listen to the starting message from \gls{cda}, 
and other agents, will wait for the availability check and inform message of the last agent in the list. 
After executing all primitives of its own, the \gls{ra} should check the availability and inform the starting point of next agent.  
Once all primitives in the list are done, the last agent should inform the \gls{cda} about the end of processing.


Before the agents start to run, the WebSocket server program (algorithm \ref{alg:ServerPseudoCode}) must be started first, so that the messages from agents will be routed to it, which serves as a \gls{ca}.  
The server runs asychronously and listen to incoming messages forever. 
Which means, every time a new agent gets connected to the server, a new thread will be started and killed after the incoming message is processed and sent to the recipient agent. 
All threads run concurrently and the maximal possible connection number is limited by the hardware and also the network bandwidth and latency. 
After the server receives a message, it should first identify the message type to check whether it is in json or string format. 
After that, it will either split the string or parse the json file to retrieve the recipient name, the priority and the message content. 
Since all message handling processes run concurrently, there is a chance that multiple messages coming in the server and waiting for processing at the same time. 
In order to rearrange them and handle the messages with higher priority first, all messages should be pushed to queue and the critical messages should be popped out first, after this the important and then normal messages. 
Finally the message will be either processed further or sent directly to the recipient. 
% Define Class...EndClass for better representation
\algnewcommand\algorithmicclass{\textbf{class}}
\algdef{SE}[CLASS]{Class}{EndClass}[1]
   {\algorithmicclass\ \textsc{#1}\vspace{0.2cm}}%
   {\vspace{0.2cm}}%

   
\begin{breakablealgorithm}
\caption{Pseudo-Code for Coordinator agent in MAS workflow}
\label{alg:CDAPseudoCode}
\begin{algorithmic}[1]
\State \textbf{Input:} custRequirement
\State {Import} WebSocket
\State {Initialize} agentID, centralServerIP
\State \textbf{Class} messageSender
    \State \textbf{\qquad function} {$send\_and\_receive(self, recipient, message, priority)$}
    \State \qquad \qquad Establish a WebSocket connection    
    \State \textbf{\qquad \qquad while} recipient not Found \textbf{do}    
    \State \qquad \qquad \qquad Send prioritized messages and wait for response

    \State \textbf{\qquad function} {$send\_capCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} recipient not found \textbf{do} 
    \State \qquad \qquad \qquad Send prioritized messages and wait for response
    \State \qquad \qquad \qquad Handle capability exceptions

    \State \textbf{\qquad function} {$send\_image\_and\_receive(self, recipient, image\_path, priority)$}
    \State \qquad \qquad {\#similar to $send\_and\_receive()$ but send an image }    
    % \State \qquad \qquad ...

    \State \textbf{\qquad function} {$send\_availCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad {\#similar to $send\_capCheck\_and\_receive()$ but raise availibility exceptions } 
    % \State \qquad \qquad ...

\State \textbf{EndClass}
\State \textbf{Class} messageReceiver
    \State \textbf{\qquad function} {$receive\_and\_send(self, response, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, process and send responses with priority
    \State \textbf{\qquad function} {$receive\_image\_and\_send(self, response, priority)$}
    \State \qquad \qquad {\#similar to $receive\_and\_send()$ but receive and save an image }    
    % \State \qquad \qquad ...    
    \State \textbf{EndClass}
\State \textbf{Class} agentsAllocation
    \State \textbf{\qquad function} {$allocate\_agents\_with\_seq\_primitives(self, requirements)$}
    \State \qquad \qquad Find tasks from customer requirements
    \State \qquad \qquad Breakdown tasks into skills into primitives
    \State \qquad \qquad Create sequence lists for primitives and agents allocation    
    \State \qquad \qquad \textbf{return} sequences
    \State \textbf{EndClass}
\State \textbf{Main:}
\State {\qquad Instantiate} agentsAllocation, messageSender and messageReceiver with agentID
\State \qquad $sequences = allocate\_agents\_with\_seq\_primitives(custRequirement)$
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_and\_receive(agent, connectMsg, priority)$
\State \qquad \textbf{until} all allocated agents connected
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_capCheck\_and\_receive(agent, primitive, priority)$
\State \qquad \textbf{until} all allocated agents capable of all primitives
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_and\_receive(agent, sequences, priority)$
\State \qquad \textbf{until} all allocated agents receive sequences
\State \qquad \qquad $send\_availCheck\_and\_receive(1st\_Agent, 1st\_primitive, priority)$
\State \qquad \textbf{repeat}
\State \qquad \qquad $receive\_and\_send(responseMsg, priority)$
\State \qquad \textbf{until} informed by last agent with finish message 
\State \textbf{End} 
\end{algorithmic}
\end{breakablealgorithm}

%pseudo code for RA
\begin{breakablealgorithm}
    \caption{Pseudo-Code for Resource agent in MAS workflow}
    \label{alg:RAPseudoCode}
    \begin{algorithmic}[1]
    \State {Import} WebSocket
    \State {Initialize} agentID, centralServerIP, subServerIP
    
\State \textbf{Class} messageSender
    \State \textbf{\qquad function} {$send\_and\_receive(self, recipient, message, priority)$}
    \State \qquad \qquad Establish a WebSocket connection    
    \State \textbf{\qquad \qquad while} recipient not Found \textbf{do}    
    \State \qquad \qquad \qquad Send prioritized messages and wait for response

    \State \textbf{\qquad function} {$send\_availCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} recipient not found \textbf{do} 
    \State \qquad \qquad \qquad Send prioritized messages and wait for response
    \State \qquad \qquad \qquad Handle availability exceptions

    \State \textbf{\qquad function} {$send\_image\_and\_receive(self, recipient, image\_path, priority)$}
    \State \qquad \qquad{\#similar to $send\_and\_receive()$ but send an image }
    % \State \qquad \qquad ...

\State \textbf{EndClass}

\State \textbf{Class} messageReceiver
    \State \textbf{\qquad function} {$receive\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, process and send responses with priority
    \State \textbf{\qquad function} {$receive\_capCheck\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, check capability and send responses with priority
    \State \qquad \qquad \qquad Handle capability exceptions
    \State \textbf{\qquad function} {$receive\_sequences\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, store sequences and send responses with priority

    \State \textbf{\qquad function} {$receive\_image\_and\_send(self, response, serverID)$}
    \State \qquad \qquad{\#similar to $receive\_and\_send()$ but receive and save an image }    
    % \State \qquad \qquad ...    
    \State \textbf{\qquad function} {$receive\_availCheck\_and\_send(self, response, serverID)$}
    \State \qquad \qquad {\#similar to $receive\_capCheck\_and\_send()$ but check availability}
    % \State \qquad \qquad ...  
    \State \textbf{EndClass}
 

   
    \State \textbf{Main:}
    \State {\qquad Instantiate} messageSender and messageReceiver with agentID
    \State \qquad $receive\_and\_send(connectMsg, centralServerID)$
    \State \textbf{\qquad repeat}
    \State \qquad \qquad $receive\_capCheck\_and\_send(capMsg, centralServerID)$
    \State \textbf{\qquad until} CapabilityCheck finished  
    \State \textbf{\qquad for} agent in sequence {\textbf do}
    \State \textbf{\qquad \qquad if} {agent is first in sequence} \textbf{then}
        \State {\qquad \qquad \qquad} $receive\_availCheck\_and\_send(availMsg, centralServerID)$
        \State \textbf{\qquad \qquad else}
        \State \textbf{\qquad \qquad \qquad if} {previous agent is not self} \textbf{then}
            \State \qquad \qquad \qquad \qquad $receive\_availCheck\_and\_send(availMsg, SubServerID)$
            \State \qquad \qquad \qquad \qquad executePrimitive(primitive)
        
            \State \textbf{\qquad \qquad \qquad if} {agent is not last one AND next agent is not self} \textbf{then}
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_availCheck\_and\_receive(nextAgent, primitive, priority)$
            \State \textbf{\qquad \qquad \qquad \qquad} executePrimitive(primitive)
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_and\_receive(nextAgent, informMsg, priority)$
         
            \State \textbf{\qquad \qquad \qquad if} {agent is last} \textbf{then}
            \State \textbf{\qquad \qquad \qquad \qquad} executePrimitive(primitive)
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_and\_receive(\gls{cda}, informFinishMsg, priority)$
            \State \textbf{\qquad end for} 
    \State \textbf{End} 
\end{algorithmic}
\end{breakablealgorithm}


%pseudo code for Server
\begin{breakablealgorithm}
    \caption{Pseudo-Code for Server in MAS workflow}
    \label{alg:ServerPseudoCode}
    \begin{algorithmic}[1]
        \State {Import} WebSocket
        \State {Initialize} serverID, priorityDict, messageQueue, connectedAgents
        \State \textbf{Do in parallel}
        \State \textbf{\qquad function} handler(WebSocket, path)  
        \State \textbf \qquad \qquad receive agent name and store in connectedAgents
        \State \textbf {\qquad \qquad while} WebSocket connected \textbf{do} 
        \State \textbf \qquad \qquad \qquad receive message from agent   
        \State \textbf{\qquad \qquad \qquad if} {message is json} \textbf{then}
        \State \textbf \qquad \qquad \qquad \qquad parse json message and retrieve recipient
        \State \textbf \qquad \qquad \qquad \qquad store agent messages in messageQueue  
        \State \textbf \qquad \qquad \qquad \qquad $process\_jsonMessage(recipient, jsonMsg)$
        \State \textbf{\qquad \qquad \qquad else}  
        \State \textbf \qquad \qquad \qquad \qquad retrieve recipient from string message
        \State \textbf \qquad \qquad \qquad \qquad store agent messages in messageQueue  
        \State \textbf \qquad \qquad \qquad \qquad $process\_message(recipient, stringMsg)$
        
        \State \textbf{\qquad function} $process\_message(recipient, stringMsg)$   
        \State \textbf \qquad \qquad prioritize messages from priorityDict and store in messageQueue 
        \State \textbf \qquad \qquad handle messages with higher priority first   
        \State \textbf \qquad \qquad send stringMsg to recipient 
        \State \textbf{\qquad function} $process\_jsonMessage(recipient, jsonMsg)$   
        \State \textbf \qquad \qquad prioritize messages from priorityDict and store in messageQueue
        \State \textbf \qquad \qquad handle messages with higher priority first 
        \State \textbf \qquad \qquad send jsonMsg to recipient
        \State \textbf{Main:}   
        \State \textbf {\qquad while} true \textbf {do}
        \State \textbf \qquad \qquad handler(WebSocket, serverID) 
        \State \textbf{End}                 
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{Pseudo-Code of one to one agent communication workflow in RESTful API}
A more comparable application layer protocol is RESTful API, which has the request-response mechanism with more addtional functionalities compared to \gls{http}. 
Therefore RESTful API was considered as an alternative of communication protocol other than WebSocket. 
However, based on some test results in chapter 4, WebSocket is proved to be more appropriate.
As a result, different from WebSocket, the design of RESTful API based system is only built for performance testing and comparison with WebSocket.
Therefore, the RESTful API system is simplified to be an one to one agent communication without other functionalities like decision making or message prioritization, etc.

According to the pseudo code for agentSR (send and receive messages) and agentRS (receive and send messages) in algorithm \ref{alg:SRPseudoCode} and \ref{alg:RSPseudoCode}, and the server in algorithm \ref{alg:apiServerPseudoCode}, 
the basic mechanism is similar to the one designed for WebSocket. One major difference is that, the connection will be closed after the message is sent from the clientSR to clientRS.
If the agentRS needs to send a response message back to inform the success, re-connection is needed. . 
Instead of send and receive from WebSocket, agentSR first POST a request to the server to call the function $send\_message()$, 
while agentRS GET a request to the server for the function call $get\_message()$, same for the reverse direction. 
Under the same condition, the message transfer routine with RESTful API will possibly results in more latency than WebSocket, which will be verified later.
  
\begin{algorithm}
    \caption{Pseudo-Code for agentSR in one to one communication workflow}
    \label{alg:SRPseudoCode}
    \begin{algorithmic}[1]
    \State {Import} flask
    \State {Initialize} agentID, serverIP
        \State \textbf{function} {$send\_and\_receive(sender, recipient, msg)$}
        \State \qquad format msg with agent IDs 
        \State \qquad post request msg to server
        \State \textbf{\qquad while} no response \textbf{do}    
        \State \qquad \qquad {$wait\_for\_response(sender, recipient)$}

        \State \textbf{function} {$wait\_for\_response(sender, recipient)$}
        \State \textbf{\qquad while} message not received \textbf{do}    
        \State \qquad \qquad get request jsonMsg from server and wait for reponse
        \State \qquad \qquad parse jsonMsg to retrieve message content
    

    \State \textbf{Main:}
    \State \qquad {$send\_and\_receive(agentID, recipient, msg)$}
    \State \textbf{End} 
    \end{algorithmic}
    \end{algorithm}


    \begin{algorithm}
        \caption{Pseudo-Code for agentRS in one to one communication workflow}
        \label{alg:RSPseudoCode}
        \begin{algorithmic}[1]
        \State {Import} flask
        \State {Initialize} agentID, serverIP
            \State \textbf{function} {$send\_message(recipient, msg)$}
            \State \qquad format msg with recipient ID 
            \State \qquad post request msg to server and wait for response 
    
            \State \textbf{function} {$get\_message(agentID)$}  
            \State \qquad get request jsonMsg from server and wait for response
            \State \qquad parse jsonMsg to retrieve message content
            \State \qquad \textbf{return} msg, recipient         
    
        \State \textbf{Main:}
        \State \qquad {$msg, recipient = get\_message(agentID)$}
        \State \textbf{\qquad if} msg AND recipient \textbf{then}   
        \State \qquad \qquad{$send\_message(recipient, msg)$}
        \State \textbf{End} 
        \end{algorithmic}
        \end{algorithm}

    \begin{algorithm}
        \caption{Pseudo-Code for server in one to one communication workflow}
        \label{alg:apiServerPseudoCode}
        \begin{algorithmic}[1]
        \State {Import} flask
        \State {Initialize} jsonMsg 
        \State \textbf{Class} app
            \State \qquad \textbf{function} {$send\_message()$}
            \State \qquad \qquad {\# POST request in app class} 
            \State \qquad \qquad parse the json file from request
            \State \qquad \qquad retrieve recipient and message content 
            \State \qquad \qquad \textbf{if} recipient AND msgContent \textbf{then}
            \State \qquad \qquad \qquad jsonify senderIP and message content and store in jsonMsg
            \State \qquad \qquad \qquad response is OK status code
            \State \qquad \qquad \textbf{else}            
            \State \qquad \qquad \qquad response is Error code            
            \State \qquad \qquad \textbf{return} response  

            \State \qquad \textbf{function} {$get\_message(agentID)$}  
            \State \qquad \qquad {\# GET request in app class} 
            \State \qquad \qquad \textbf{if} agentID in jsonMsg \textbf{then}
            \State \qquad \qquad \qquad send jsonMsg and response is OK status code
            \State \qquad \qquad \textbf{else}
            \State \qquad \qquad \qquad response is Error code
            \State \qquad \qquad \textbf{return} response         
    
        \State \textbf{Main:}
        \State \qquad Instantiate app
        \State \qquad run app forever
        \State \textbf{End} 
        \end{algorithmic}
        \end{algorithm}

\section{External}


\subsection{Overview (conceptual diagram)}

%figure conceptual DT
\begin{figure}[htb]
\includegraphics[width=\textwidth]{figures/DT_Conceptual_Diagram.png}

\centering
\caption{Conceptual diagram of MAS\label{fig: DTConceptual}}
\end{figure}

The figure \ref{fig: DTConceptual} shows the workflow of \gls{dt} agent updating global \gls{dt}.
The process begins from the left hand side of the graph. The \gls{dt} agent receives process data constantly from robots, including steady state data. 
After the separating the sticky packets from \gls{tcp} socket, the process data will be parsed and uploaded one by one to the \gls{ms} Azure Digital Twin cloud. 
All the updates of the digital twin instances in cloud will be shown in \gls{ms} Azure Digital Twin Explorer temporarily and stored in Azure Event Hubs concurrently. 
After that the history data could be ingested for further analysis in Azure Data Explorer. 
The Azure Digital Twin Explorer here serves as a monitor of robot status while the Azure Data Explorer as a data analysis tool. 
Once the remote data update is successful, the data will be downloaded to local host immediately and may be further used as inputs of any other visualization purposes. 
Within this upload and download cycle of data, the real time capability should also be maintained.  



It is worth mentioning that, the process data is produced by robot motion which makes the \gls{dt} agent completely decoupled from the \gls{mas}. 
The advantages of the decoupling is that, even though there is a complete disorder of the \gls{mas}, the current robot states will be recorded and updated in remote, 
which is beneficial for data acquisition and monitoring. 



\subsection{Prerequisite}
\subsubsection{\gls{ntp} Setup}
In order to measure the delays between local host and cloud, the clock of both end must be synchronized. 
Due to the nature of computer systems, the software clock might drift away from the "true" time (absolute \gls{utc} time) due to various reasons like system load, hardware imperfections, or even temperature changes.
Therefore, before the measurement, the software clock of local host should be synchronized with the global clock using \gls{ntp}. 
The NTP setup of linux system are:  

\begin{enumerate}
    \item System update and upgrade.
    \item Install \gls{ntp}.
    \item Add reliable global \gls{ntp} servers/server pools to configure ntp.conf file.
    \item Allow port 123/udp for or disable firewall.
    \item Restart \gls{ntp} and check \gls{ntp} status.
    \item Check synchronization status (e.g.: reach, delay, offset and jitter, etc).
    \end{enumerate}

Since the cloud system clock is already synchronized with \gls{utc} time, all the tests and calculations results are based on UTC time. 

\subsection{Pseudo-Code of \gls{rcp} and \gls{dt} agent workflow in C++ and C\#}
%pseudo code for RCP

\begin{breakablealgorithm}
    \caption{Pseudo-Code of \gls{rcp} workflow}
    \label{alg:RCPPseudoCode}
    \begin{algorithmic}
    \State {Import} socket, franka
    \State {Initialize} DTAgentIP
    \State \textbf{function} {$get\_rState\_and\_send(clientSocket)$}
        \State \qquad Start robot motion and record robot state
        \State \qquad {$send\_message(robotState, clientSocket)$}
    \State \textbf{function} {$send\_message(msg, clientSocket)$}
        \State \qquad 
    \State \textbf{Main:}
    \State \qquad Instantiate robot
    \State \qquad Initialize start position
    \State \qquad Establish a \gls{tcp} connection with \gls{dt} agent  
    \State \qquad {$get\_rState\_and\_send(clientSocket)$}
    \State \textbf{End}
    \end{algorithmic}
\end{breakablealgorithm}

\begin{breakablealgorithm}
    \caption{Pseudo-Code of \gls{dt} agent workflow}
    \label{alg:DTAgentPseudoCode}
    \begin{algorithmic}
    \State {Import} socket, AzureDigitalTwin
    \State {Initialize} agentIP(s)
    \State \textbf{function} {$read\_and\_upload\_download\_processData(agentIP)$}
        \State \qquad \textbf{do run in parallel}
            \State \qquad \qquad $create\_client\_thread(agentIP)$       
    \State \textbf{function} {$create\_client\_thread(agentIP)$}
        \State \qquad Establish a \gls{tcp} connection with \gls{ra}
        \State \qquad {$data = read\_data(clientSocket)$}  
        \State \qquad {$process\_data\_upload\_and\_download(data)$}    
    \State \textbf{function} {$read\_data(clientSocket)$}
        \State \qquad receive and store data
        \State \qquad \textbf{return} data
    \State \textbf{function} {$process\_data\_upload\_and\_download(data)$}
        \State \qquad separate sticky packets with delimiter
        \State \qquad upload processed data to Azure \gls{dt} in json patch
        \State \qquad download twin after data update 
    \State \textbf{Main:}
        \State \qquad \textbf{for} agentIP in IPs \textbf{do}
        \State \qquad \qquad {$read\_and\_upload\_download\_processData(agentIP)$}
        \State \textbf{End}
    \end{algorithmic}
\end{breakablealgorithm}



\subsection{MS Azure Digital Twin}
Azure Digital twin database setup