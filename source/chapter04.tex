% !TeX spellcheck = en_US
\chapter{Methodology}\label{chap: Meth}%
To realize the decentralization of \gls{mas}, we divided the general \gls{mas} into 
two parts. The local \gls{mas} (section \ref{chap: Meth-Internal}) to achieve agent 
collaboration and the global \gls{dt} (section \ref{chap: Meth-External})
for cloud-based digital mapping of physical entities. The local \gls{mas} 
includes a \gls{mas} for the \gls{cda}, \gls{ca} and \gls{ra}, 
while the global \gls{dt} represents the cloud-based \gls{dta}. 
Although these two systems are decoupled from each other, 
they both follow the principles of an agent-based operating system. 
At the end, it concludes the timing properties for both 
local \gls{mas} and global \gls{dt} with communication protocols in 
different layers and suggests a way to represent 
network latency modularly using visual notation of \gls{dsl}. 




\section{Local \gls{mas}}\label{chap: Meth-Internal}%

This section discusses the selected design pattern for \gls{mas} along 
with the responsibilities of each module within it.
It then compares the features of transport layer protocols with those of 
application layer protocols.
Eventually the methods for using python WebSocket for \gls{mas} and 
RESTful API for one to one agent communication are presented in form of pseudocode. 


\subsection{Decentralization of \gls{mas}}
The design of our local \gls{mas} relies on the decentralization 
schemes in fig.\ref{fig: CentralizeDecentralizeConcept}. 
Based on the use cases from BMW and Wittenstein, all the agents can be roughly 
divided into two kinds, the management level master agent and the field-level sub-agents. 
The \gls{cda} represents the former, while the others belong to the latter ones, 
including the storage agent, transport agent, wiring agent and assembly agent. For 
convenience we will refer to all sub-agents as \gls{ras}. Addtionally, we included 
a \gls{ca} to handle real-time communication between agents in different levels. 


\subsection{\gls{mas} design based on Wannagat's architecture}

%figure conceptual MAS
\begin{figure}[htb]
\includegraphics[width=\textwidth]{figures/MAS_Conceptual_Diagram.pdf}
\centering
\caption{Conceptual diagram of MAS\label{fig: MASConceptual}}
\end{figure}

% decribe the conceptual diagram
For the modularization purposes, Wannagat's architecture is chosen for the 
system design because of its concentration on field-level operation over other 
design architectures, such as Fischer’s and Ryashentseva’s architecture that focus 
on higher levels in production system.  
Fig.\ref{fig: MASConceptual} shows a conceptual diagram of a \gls{mas} based 
on the \gls{ra} design patterns 
in Wannagat’s architecture\cite{cruz_salazar_cyber-physical_2019}, 
focusing on communication between agents, 
planning, and decision-making inside each agent. The \gls{cda} here is identical 
to \gls{ams} of Wannagat’s architecture, which should also be considered an agent 
instead of a management system. The five modules within an agent are:

\begin{itemize}
    \item Planning Module
    \item Control Module
    \item Knowledge Base
    \item Diagnosis Module
    \item Communication Interface
\end{itemize}

for both \gls{cda} and \gls{ra}.
Based on these five modules, the agent tasks can be categorized into five parts. Some 
of them have been included in our \gls{mas}, while the others should be considered in the 
next design steps. 


Firstly, in the planning module, it normally contains requirements like task planning, 
decision making, 
resource allocation, sequencing and scheduling. It has been mostly explored in our 
design, except for the communication Interface module. Inside a \gls{cda}, 
for the task planning, we introduced 
a mechanism to break down tasks into smaller executable units (primitives). 
The decision 
making process is also enabled by including functionalities that can decide which task should be 
assigned to which agent based on the local \gls{db}. After that, for a better resource 
allocation, the allocated agents will be assigned with these tasks. What has not been 
considered is the scheduling tasks. It would be ideal if each agent could calculate 
the primitive execution time before starting.

Secondly, the control module should be able to perform tasks like monitoring, adaptation, 
control and optimization, resource allocation and actuation and many more. The only part 
performed in our design is the actuation. All \gls{ras} can actuate the robot's operation 
unit by calling the primitives actuation functions. Other tasks, such as monitoring the 
robot states, adapting the plans with current states (e.g., emergent stop), control and 
optimizing the robot's motion are not under consideration in the work. 


The knowledge base module is another important module in general. 
The module consists of lot of components and tasks including \gls{db}, knowledge representation and reasoning, learning and knowledge 
sharing tasks. For DB design, it can be either hierarchical, relational, non-relational 
or object-oriented. In our work, the \gls{db} design of \gls{cda} is based on a 
hierarchical task decomposition structure. They are used to represent and reason task-related 
knowledges. 
Other parts like learning from new tasks or sharing knowledges between agents are not considered here.  


Although less concerned in the work, the diagnosis module is also important for fault 
detection, diagnosis and prediction, and root cause analysis and classification. Among all, 
only fault detection here is relevant to our work. In a \gls{ra}, an exception can be raised 
if the agents are currently not available or capable of primitives. 


The last module is the most important module in our case, which is responsible for agent 
communications. This module is embedded in each agent, or as the main module in \gls{ca}. 
Common tasks, for example, are message parsing and encoding, connection 
establishment, message handling, message queuing and data security. 
All tasks are executed at least once 
except for the security issues in our case. Here are some examples for each: 
messages are generally encoded and decoded into agent specific data types, a stable 
connection can be ensured for constant data exchange, and messages can be prioritized in a 
queue inside a \gls{ca}. 


\subsection{\gls{osi} model and comparison between sockets relevant protocol layers}
%figure conceptual MAS
\begin{figure}[htbp]
\includegraphics[width=0.6\textwidth]{figures/OSI.pdf}
\centering
\caption{\gls{osi} model with example protocols \label{fig: OSI}}
\end{figure}

An important aspect in agent communication is the communication protocols 
in different layers. 
Fig.\ref{fig: OSI} shows the famous OSI model with seven abstraction layers, with Transport and 
application layers mostly relevant to network communication. TCP and UDP are typical transport layer 
protocols, and they provide a more abstract and generic service for reliable data transfer, 
while the application layer protocols like HTTP or Websocket are designed for applcations with 
more user-specific functionalities. Although the application layer protocols are still based on 
TCP/UDP, they defined additional "rules" to 
specify the structure, content, and semantics of the messages transport. 


To choose one protocol over the others, we considered the Characteristics and compared 
those with our requirements of system design. Firstly, 
protocols within the same layer should be compared. In our studies, \gls{tcp} is chosen 
over \gls{udp}, while WebSocket is chosen over other comparable protocols 
such as \gls{http} and \gls{mqtt}. The decision is mainly done by comparison of their 
characteristics related to the design requirements. 



\subsubsection{TCP as communication protocols}
\gls{tcp} as communication protocol is chosen based on the following characteristics: 
\begin{itemize}
    \item Use case
    \item Reliability
    \item Connection type
    \item Overhead 
    \item Sequence
    \item Retransmission of lost Packets
    \item Speed
    \item State
\end{itemize}
Normally, \gls{tcp} and \gls{udp} are used in difference use cases with different focus. 
TCP are usually the communication protocols for email, text messages and file transfers where a 
reliable connection is needed. It manages the pace of data transmission to avoid overload of 
the receiver side. Moreover, it stores the information about system to enable tracking. The 
packet loss rate is minimized in a reliable network configuration with the guarantee of the 
data retransmission mechanism and packet sequencing. However, it comes along with the 
drawbacks. To ensure the 
reliability, \gls{tcp} is designed with larger overhead than \gls{udp}, which results in a 
lower data transmission speed. Besides, a three handshake connection needs to be established 
which adds up extra delay. 


On the other hand, \gls{udp} is mostly used for live and real-time stream data transmission. 
Although suitable for real-time system based on the stateless and connectionless 
properties, and its lightweight overhead, \gls{udp} is not under consideration in our 
design based on its unreliability and non-sequencing properites. The packet loss rate is 
relative higher because no retransmission of data is possible. Last but not the least, 
the packets may come in a different ordering, which results in problems in reconstructing 
data files at the receiver side.  

In a \gls{mas}, a reliable and direct communication between each agent should be 
guaranteed under a real time requirement, 
which leads to the choice of \gls{tcp} over \gls{udp}. 
 


\subsubsection{WebSocket as communication protocols}
Compared to transport layer protocols, applcation layer protocols provide more 
application-specific services. The choice of the protocols are again mainly based on the 
design requirements. Hence, three commonly used protocols, \gls{http}, 
WebSocket and \gls{mqtt}, are compared horizontally with each other for their 
requirement-specific characteristics:

\begin{itemize}
    \item Use case
    \item Functionality
    \item Message patterns 
    \item Connection types
    \item State
    \item Overhead
    \item Real-time capability
    \item Flexibility
    \item Adaptability to dynamic changes
    \item Capability of handling instability
    \item Scalability
\end{itemize}

\gls{http}, a networking protocol, is widely used for web pages, images, videos, World 
Wide Web and many more. Its function operates in the following manners: a 
request-response based message pattern that serves as the foundation for some third-party 
communication application such as RESTful API and used for the initial connection of WebSocket. The connection 
of \gls{http} protocol is non-persistent and the connection will be closed after 
each individual request-response cycle. The communication is stateless with additional 
overhead for each request-response cycle, especially for new connections. Therefore, 
it is less capable of handling real-time activities. Among all other protocols, 
\gls{http} benefits from its high flexibility in all environments, while in contrast, less 
adaptable to dynamic changes, less capable of stable connection and less scalable 
in many cases compared to the other two protocols. 

Another option should be the WebSocket, which is for example used for chat 
applications and live gaming, providing a real-time, bi-directional, stateful and full 
duplex communication 
solution. The term bi-directional means that, once the connection is established, 
either the client or the server can send a message to each other simultaneously, and Full 
duplex indicates the independency of data flow in both directions. WebSocket is suitable 
for real time application because of its persistent connection, meaning that the connection 
will stay until it is closed specially. This mechanism greatly reduces the delay for 
reconnections. WebSocket also has the advantages of being highly flexible in most modern 
web browser and many backend environments, its high adaptability and scalability. The only 
drawback for the implementation of \gls{mas} could be its instability by constant disconnections. 


The last comparable protocol should be the \gls{mqtt} that is usually integrated in 
\gls{iot} with limited bandwidth. It has many leading points for 
\gls{mas} design. It is highly suitable for real time systems with persistent connection, 
benefited from the statefulness property, and a minimal message overhead. The system 
based on \gls{mqtt} is highly real-time capable, flexible, adaptable to dynamic changes, 
capable of handling instability and highly scalable on broker-client message transport. 
Nevertheless, it is not adapted for system design based on its publish-subscribe message pattern. 
As depicted in fig.\ref{fig: MsgConceptual}, the conceptual grapgh illustrates 
the differences between bi-directional 
full-duplex and other message patterns, such as Request-Response and Publish-Subscribe, 
in the context of data transport.
For the \gls{mqtt}, the publisher publishes (sends) a 
message within a topic to the broker (server), while the subscriber 
subscribes (receives) the message from the broker within the same topic. 
For response, a new topic needs to start, but there is no guarantee that the original publisher is listening, 
which is a drawback for send-and-receive patterns of \gls{mas}. 

Out of the three protocols, we consider \gls{http} and WebSocket more appropriate for our 
\gls{mas} in the early design stage. The final choice of using WebSocket will be verified 
by the test results in section \ref{chap: Result-RestFUL_WS}.


%figure conceptual application layer protocols
\begin{figure}[htb]
\includegraphics[width=0.8\textwidth]{figures/MessageConceptual.png}
\centering
\caption{Conceptual diagram of different applcation layer 
protocols\label{fig: MsgConceptual}}
\end{figure}





\subsection{WebSocket and \gls{tcp}}
In the final stage of the system design, WebSocket is chosen over \gls{tcp} as 
base communication protocols. There are several reasons for the choice. 
In the most basic communication mode according to \cite{vogel-heuser_delay_2023} 
is based on \gls{tcp} utilizing sockets (data transport endpoints in 
program), which is beneficial for one-to-one, 
or more-to-one, but never a more-to-more agent communication. This is based on 
the fact that, client/-s should always start before the server. Assume that 
each agent is both a server and a client at the same time, the more-to-more 
agent communication will greatly enhance the complexity of the data exchange 
and also consumes too much\gls{cpu} power. To be more specific, for a 
system of five agents, each agent has at least four threads for communication, 
which enables the agent to switch between the role of clients and servers, 
making it impossible for real-time communication. The complex interconnections 
between agents is shown in fig.\ref{fig: threadMASConceptual}.

\begin{figure}[htb]
    \includegraphics[width=\textwidth]{figures/threads_MAS.pdf}
    \centering
    \caption{Conceptual diagram of \gls{mas} communication based on 
    \gls{tcp} sockets, agent can be either client or agent by creating 
    multiple threads. \label{fig: threadMASConceptual}}
\end{figure}



After some unfeasible attempts, the demand to design a \gls{ca} that collect 
messages from sender agents, process them and futher transport them to the 
receiver agents has increased. Therefore, a server built with WebSocket serves 
as the \gls{ca}. Since the server should have many addtional 
capabilities including queuing messages, providing simple APIs for sending 
and receiving messages and many more, raw bytes transport with \gls{tcp} is 
less under consideration for a complex \gls{mas}. However, \gls{tcp} socket 
may be more suitable for more-to-one communication for \gls{dta}, 
with its details described in section \ref{chap: RCPTCP-DTAPI}.  


\subsection{Prerequisite}
\subsubsection{System Setup}
 
%figure conceptual MAS
\begin{figure}[htbp]
\includegraphics[width=0.8\textwidth]{figures/NamespaceConceptual.pdf}
\centering
\caption{Conceptual diagram of namespaces creation
\label{fig: NSConceptual}}
\end{figure}

After choosing the suitable design architecture and protocols, the detailed 
software design for \gls{mas} and performance testing methods will be described below. 

Before simulating network environments for agent communication testing 
and development of the \gls{mas}, the internal packet routing between agents 
in a single Linux device should be avoided. A common way to visualize 
the network for performance testing is to use namespaces for network 
emulation. The trick is that a process running within a given
namespace will see only the network interfaces, including, for example, 
virtual interfaces and forwarding tables, that exist in that namespace. 
The applications under test should serve as a
switch, and each packet should be routed through these interfaces. 
Fig.\ref{fig: NSConceptual} shows that each namespace is assigned 
a virtual ethernet interface, 
starting with the name eth, along with an individual IP address. 
Each time a script gets called, it runs under a namespace with its 
IP address. In exercise, if a packet is sent from
Namespace 1 to 3 and then back; it is routed by the switch instead of 
bridges between namespaces to avoid internal routing. This external routing 
device is useful for delay measurement between each agent through 5G Network, 
by introducing external delays to estimate the network environment. 


\subsection{Pseudo-Code of MAS workflow in WebSocket python}\label{chap: Meth-WS-MAS}
The local \gls{mas} application is named as Websocket\_MAS, which is designed under the 
environment of Ubuntu 20.04 LTS with Python 3.10. 
In algorithm \ref{alg: CDAPseudoCode} is a piece of pseudocode that reflects the workflow of the \gls{mas} for the \gls{cda}. 
Unlike other \gls{ras}, \gls{cda} has no mechanisms of primitive execution but the ability to do planning and decision-making. 
Under the Main, the production tasks are broken down into a list of sequenced primitives and then assigned to each allocated agent through one of the predefined $send\_and\_receive()$ functions under the messageSender class.
After getting responses from the agents, \gls{cda} should decide whether to start processing positive responses or retry the steps by negative responses.  
Once the production process starts, the \gls{cda} assumes the role of a coordinator and waits for inform messages from the allocated agents. It does so by using one of the $receive\_and\_send()$ functions under the messageReceiver class. This allows the \gls{cda} to have overall control of the entire production process and centralize the distributed agent systems.


As for the decentralization of \gls{mas}, the \gls{ra} should be able to react to \gls{cda} and do the decision-making for its field-level control, which means \gls{cda} should only be informed about the status of the production process. In contrast, the exact processes should be done within \gls{ra}, and the material flow should be informed between \gls{ras}. The combination of centralization and decentralization will save the resource power consumed by \gls{cda}, 
while still maintaining the management level control and decision-making.  
The algorithm \ref{alg: RAPseudoCode} shows the logic of a \gls{ra}. At the beginning, \gls{ra} waits for the connection and capability check from \gls{cda}. After that, the first agent in the list of $sequenced\_agent$ will listen to the starting message from \gls{cda}. 
Moreover, other agents will wait for the availability check and inform messages from the last agent on the list. 
Once the \gls{ra} has completed its own primitives, it should check for the availability of the next agent and inform its starting point. 
Once all primitives in the list are executed, the last agent should inform the \gls{cda} about the end of processing.


Before the agents start to run, the WebSocket server program (algorithm \ref{alg: ServerPseudoCode}) must be started first so that the messages from agents will be routed to it, which serves as a \gls{ca}.  
The server runs asynchronously and listens to incoming messages forever, meaning that every time a new agent gets connected, a new thread will be started and killed after the incoming message is processed and sent to the recipient agent. 
All threads run concurrently, and the hardware limits the maximum possible connection number and also the network bandwidth and latency. 
After the server receives a message, it should identify the message type to check whether it is in JSON or string format. 
After that, it will split the string or parse the JSON file to retrieve the recipient name, the priority, and the message content. 
Since all message-handling processes run concurrently, there is a chance that multiple messages are coming into the server and waiting for processing at the same time. 
In order to rearrange them and handle the messages with higher priority in advance, all messages should be pushed to the queue, and the critical messages should be popped out first. The critical messages have the highest priority, and after this, the important and then the normal messages. 
Finally, the message will be processed further or sent directly to the recipient. 
   
\begin{breakablealgorithm}
\caption{Pseudo-Code for \gls{cda} in MAS workflow}
\label{alg: CDAPseudoCode}
\begin{algorithmic}[1]
\State \textbf{Input:} custRequirement
\State {Import} WebSocket
\State {Initialize} agentID, centralServerIP
\State \textbf{Class} messageSender
    \State \textbf{\qquad function} {$send\_and\_receive(self, recipient, message, priority)$}
    \State \qquad \qquad Establish a WebSocket connection    
    \State \textbf{\qquad \qquad while} recipient not Found \textbf{do}    
    \State \qquad \qquad \qquad Send prioritized messages and wait for response

    \State \textbf{\qquad function} {$send\_capCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} recipient not found \textbf{do} 
    \State \qquad \qquad \qquad Send prioritized messages and wait for response
    \State \qquad \qquad \qquad Handle capability exceptions

    \State \textbf{\qquad function} {$send\_image\_and\_receive(self, recipient, image\_path, priority)$}
    \State \qquad \qquad {\#similar to $send\_and\_receive()$ but send an image }    
    % \State \qquad \qquad ...

    \State \textbf{\qquad function} {$send\_availCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad {\#similar to $send\_capCheck\_and\_receive()$ but raise availibility exceptions } 
    % \State \qquad \qquad ...

\State \textbf{EndClass}
\State \textbf{Class} messageReceiver
    \State \textbf{\qquad function} {$receive\_and\_send(self, response, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, process and send responses with priority
    \State \textbf{\qquad function} {$receive\_image\_and\_send(self, response, priority)$}
    \State \qquad \qquad {\#similar to $receive\_and\_send()$ but receive and save an image }    
    % \State \qquad \qquad ...    
    \State \textbf{EndClass}
\State \textbf{Class} agentsAllocation
    \State \textbf{\qquad function} {$allocate\_agents\_with\_seq\_primitives(self, requirements)$}
    \State \qquad \qquad Find tasks from customer requirements
    \State \qquad \qquad Breakdown tasks into skills into primitives
    \State \qquad \qquad Create sequence lists for primitives and agents allocation    
    \State \qquad \qquad \textbf{return} sequences
    \State \textbf{EndClass}
\State \textbf{Main:}
\State {\qquad Instantiate} agentsAllocation, messageSender and messageReceiver with agentID
\State \qquad $sequences = allocate\_agents\_with\_seq\_primitives(custRequirement)$
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_and\_receive(agent, connectMsg, priority)$
\State \qquad \textbf{until} all allocated agents connected
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_capCheck\_and\_receive(agent, primitive, priority)$
\State \qquad \textbf{until} all allocated agents capable of all primitives
\State \qquad \textbf{repeat}
\State \qquad \qquad $send\_and\_receive(agent, sequences, priority)$
\State \qquad \textbf{until} all allocated agents receive sequences
\State \qquad \qquad $send\_availCheck\_and\_receive(1st\_Agent, 1st\_primitive, priority)$
\State \qquad \textbf{repeat}
\State \qquad \qquad $receive\_and\_send(responseMsg, priority)$
\State \qquad \textbf{until} informed by last agent with finish message 
\State \textbf{End} 
\end{algorithmic}
\end{breakablealgorithm}

%pseudo code for RA
\begin{breakablealgorithm}
    \caption{Pseudo-Code for \gls{ra} in MAS workflow}
    \label{alg: RAPseudoCode}
    \begin{algorithmic}[1]
    \State {Import} WebSocket
    \State {Initialize} agentID, centralServerIP, subServerIP
    
\State \textbf{Class} messageSender
    \State \textbf{\qquad function} {$send\_and\_receive(self, recipient, message, priority)$}
    \State \qquad \qquad Establish a WebSocket connection    
    \State \textbf{\qquad \qquad while} recipient not Found \textbf{do}    
    \State \qquad \qquad \qquad Send prioritized messages and wait for response

    \State \textbf{\qquad function} {$send\_availCheck\_and\_receive(self, recipient, primitive, priority)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} recipient not found \textbf{do} 
    \State \qquad \qquad \qquad Send prioritized messages and wait for response
    \State \qquad \qquad \qquad Handle availability exceptions

    \State \textbf{\qquad function} {$send\_image\_and\_receive(self, recipient, image\_path, priority)$}
    \State \qquad \qquad{\#similar to $send\_and\_receive()$ but send an image }
    % \State \qquad \qquad ...

\State \textbf{EndClass}

\State \textbf{Class} messageReceiver
    \State \textbf{\qquad function} {$receive\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, process and send responses with priority
    \State \textbf{\qquad function} {$receive\_capCheck\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, check capability and send responses with priority
    \State \qquad \qquad \qquad Handle capability exceptions
    \State \textbf{\qquad function} {$receive\_sequences\_and\_send(self, response, serverID)$}
    \State \qquad \qquad Establish a WebSocket connection
    \State \textbf{\qquad \qquad while} message not received \textbf{do}
    \State \qquad \qquad \qquad Receive, store sequences and send responses with priority

    \State \textbf{\qquad function} {$receive\_image\_and\_send(self, response, serverID)$}
    \State \qquad \qquad{\#similar to $receive\_and\_send()$ but receive and save an image }    
    % \State \qquad \qquad ...    
    \State \textbf{\qquad function} {$receive\_availCheck\_and\_send(self, response, serverID)$}
    \State \qquad \qquad {\#similar to $receive\_capCheck\_and\_send()$ but check availability}
    % \State \qquad \qquad ...  
    \State \textbf{EndClass}
 

   
    \State \textbf{Main:}
    \State {\qquad Instantiate} messageSender and messageReceiver with agentID
    \State \qquad $receive\_and\_send(connectMsg, centralServerID)$
    \State \textbf{\qquad repeat}
    \State \qquad \qquad $receive\_capCheck\_and\_send(capMsg, centralServerID)$
    \State \textbf{\qquad until} CapabilityCheck finished  
    \State \textbf{\qquad for} agent in sequence {\textbf do}
    \State \textbf{\qquad \qquad if} {agent is first in sequence} \textbf{then}
        \State {\qquad \qquad \qquad} $receive\_availCheck\_and\_send(availMsg, centralServerID)$
        \State \textbf{\qquad \qquad else}
        \State \textbf{\qquad \qquad \qquad if} {previous agent is not self} \textbf{then}
            \State \qquad \qquad \qquad \qquad $receive\_availCheck\_and\_send(availMsg, SubServerID)$
            \State \qquad \qquad \qquad \qquad executePrimitive(primitive)
        
            \State \textbf{\qquad \qquad \qquad if} {agent is not last one AND next agent is not self} \textbf{then}
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_availCheck\_and\_receive(nextAgent, primitive, priority)$
            \State \textbf{\qquad \qquad \qquad \qquad} executePrimitive(primitive)
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_and\_receive(nextAgent, informMsg, priority)$
         
            \State \textbf{\qquad \qquad \qquad if} {agent is last} \textbf{then}
            \State \textbf{\qquad \qquad \qquad \qquad} executePrimitive(primitive)
            \State \textbf{\qquad \qquad \qquad \qquad} $send\_and\_receive(\gls{cda}, informFinishMsg, priority)$
            \State \textbf{\qquad end for} 
    \State \textbf{End} 
\end{algorithmic}
\end{breakablealgorithm}


%pseudo code for Server
\begin{breakablealgorithm}
    \caption{Pseudo-Code for \gls{ca} as a server in MAS workflow}
    \label{alg: ServerPseudoCode}
    \begin{algorithmic}[1]
        \State {Import} WebSocket
        \State {Initialize} serverID, priorityDict, messageQueue, connectedAgents
        \State \textbf{Do in parallel}
        \State \textbf{\qquad function} handler(WebSocket, path)  
        \State \textbf \qquad \qquad receive agent name and store in connectedAgents
        \State \textbf {\qquad \qquad while} WebSocket connected \textbf{do} 
        \State \textbf \qquad \qquad \qquad receive message from agent   
        \State \textbf{\qquad \qquad \qquad if} {message is json} \textbf{then}
        \State \textbf \qquad \qquad \qquad \qquad parse json message and retrieve recipient
        \State \textbf \qquad \qquad \qquad \qquad store agent messages in messageQueue  
        \State \textbf \qquad \qquad \qquad \qquad $process\_jsonMessage(recipient, jsonMsg)$
        \State \textbf{\qquad \qquad \qquad else}  
        \State \textbf \qquad \qquad \qquad \qquad retrieve recipient from string message
        \State \textbf \qquad \qquad \qquad \qquad store agent messages in messageQueue  
        \State \textbf \qquad \qquad \qquad \qquad $process\_message(recipient, stringMsg)$
        
        \State \textbf{\qquad function} $process\_message(recipient, stringMsg)$   
        \State \textbf \qquad \qquad prioritize messages from priorityDict and store in messageQueue 
        \State \textbf \qquad \qquad handle messages with higher priority first   
        \State \textbf \qquad \qquad send stringMsg to recipient 
        \State \textbf{\qquad function} $process\_jsonMessage(recipient, jsonMsg)$   
        \State \textbf \qquad \qquad prioritize messages from priorityDict and store in messageQueue
        \State \textbf \qquad \qquad handle messages with higher priority first 
        \State \textbf \qquad \qquad send jsonMsg to recipient
        \State \textbf{Main:}   
        \State \textbf {\qquad while} true \textbf {do}
        \State \textbf \qquad \qquad handler(WebSocket, serverID) 
        \State \textbf{End}                 
    \end{algorithmic}
\end{breakablealgorithm}

\subsection{Pseudo-Code of one to one agent communication workflow in RESTful API}
A more comparable application layer protocol is \gls{http}, which has the request-response mechanism with more additional functionalities compared to \gls{http}. 
Therefore, \gls{http} was considered an alternative communication protocol other than WebSocket. 
However, based on some test results in chapter \ref{chap: Result}, WebSocket is more appropriate.
As a result, different from WebSocket, the design of \gls{http} based system is only built for performance testing and compared to WebSocket. In the methods below, RESTful API will be used as a Web Service API, an interface to connect two devices over the internet based on \gls{http} protocol. With the design based on RESTful API, the clients can communicate with each other by using its standard \gls{crud} operations, for example, POST and GET, to send and receive messages. 
Therefore, the RESTful API system is simplified to one-to-one agent communication without other functionalities like decision-making or message prioritization, among others.


According to the pseudo-code for agentSR (send and receive messages) and agentRS (receive and send messages) in algorithm \ref{alg: SRPseudoCode} and \ref{alg: RSPseudoCode}, and the server in algorithm \ref{alg: apiServerPseudoCode}, the primary mechanism is similar to the one designed for WebSocket. One significant difference is that the connection will be closed after the message is sent from the clientSR to clientRS. If the agentRS needs to send a response message back to inform the success, re-connection is needed. 
Instead of sending and receiving from WebSocket, agentSR first POST a request to the server to call the function $send\_message()$, 
while agentRS GET a request to the server for the function call $get\_message()$, same for the reverse direction. 
Under the same condition, the message transport routine with RESTful API may result in more latency than WebSocket, which will be verified later.
\begin{algorithm}
    \caption{Pseudo-Code for agentSR in one to one communication workflow}
    \label{alg: SRPseudoCode}
    \begin{algorithmic}[1]
    \State {Import} flask
    \State {Initialize} agentID, serverIP
        \State \textbf{function} {$send\_and\_receive(sender, recipient, msg)$}
        \State \qquad format msg with agent IDs 
        \State \qquad post request msg to server
        \State \textbf{\qquad while} no response \textbf{do}    
        \State \qquad \qquad {$wait\_for\_response(sender, recipient)$}

        \State \textbf{function} {$wait\_for\_response(sender, recipient)$}
        \State \textbf{\qquad while} message not received \textbf{do}    
        \State \qquad \qquad get request jsonMsg from server and wait for reponse
        \State \qquad \qquad parse jsonMsg to retrieve message content
    

    \State \textbf{Main:}
    \State \qquad {$send\_and\_receive(agentID, recipient, msg)$}
    \State \textbf{End} 
    \end{algorithmic}
    \end{algorithm}


    \begin{algorithm}
        \caption{Pseudo-Code for agentRS in one to one communication workflow}
        \label{alg: RSPseudoCode}
        \begin{algorithmic}[1]
        \State {Import} flask
        \State {Initialize} agentID, serverIP
            \State \textbf{function} {$send\_message(recipient, msg)$}
            \State \qquad format msg with recipient ID 
            \State \qquad post request msg to server and wait for response 
    
            \State \textbf{function} {$get\_message(agentID)$}  
            \State \qquad get request jsonMsg from server and wait for response
            \State \qquad parse jsonMsg to retrieve message content
            \State \qquad \textbf{return} msg, recipient         
    
        \State \textbf{Main:}
        \State \qquad {$msg, recipient = get\_message(agentID)$}
        \State \textbf{\qquad if} msg AND recipient \textbf{then}   
        \State \qquad \qquad{$send\_message(recipient, msg)$}
        \State \textbf{End} 
        \end{algorithmic}
        \end{algorithm}

    \begin{algorithm}
        \caption{Pseudo-Code for a server in one to one communication workflow}
        \label{alg: apiServerPseudoCode}
        \begin{algorithmic}[1]
        \State {Import} flask
        \State {Initialize} jsonMsg 
        \State \textbf{Class} app
            \State \qquad \textbf{function} {$send\_message()$}
            \State \qquad \qquad {\# POST request in app class} 
            \State \qquad \qquad parse the json file from request
            \State \qquad \qquad retrieve recipient and message content 
            \State \qquad \qquad \textbf{if} recipient AND msgContent \textbf{then}
            \State \qquad \qquad \qquad jsonify senderIP and message content and store in jsonMsg
            \State \qquad \qquad \qquad response is OK status code
            \State \qquad \qquad \textbf{else}            
            \State \qquad \qquad \qquad response is Error code            
            \State \qquad \qquad \textbf{return} response  

            \State \qquad \textbf{function} {$get\_message(agentID)$}  
            \State \qquad \qquad {\# GET request in app class} 
            \State \qquad \qquad \textbf{if} agentID in jsonMsg \textbf{then}
            \State \qquad \qquad \qquad send jsonMsg and response is OK status code
            \State \qquad \qquad \textbf{else}
            \State \qquad \qquad \qquad response is Error code
            \State \qquad \qquad \textbf{return} response         
    
        \State \textbf{Main:}
        \State \qquad Instantiate app
        \State \qquad run app forever
        \State \textbf{End} 
        \end{algorithmic}
        \end{algorithm}



\section{Global Digital Twin} \label{chap: Meth-External}
In section \ref{chap: Overview-External}, the data flow for the external 
\gls{dta} system will be presented. Following that, section \ref{chap: ntpsetup} 
will explain the \gls{ntp} setup used to measure delays between local devices and 
the cloud. To better understand the workflow, the pseudo-code for both \gls{rcp} 
and \gls{dta} will be provided in section \ref{chap: RCPDTAPseudo}. Lastly, the 
final section will cover the setup of the Azure \gls{dt} platform for data ingestion.



\subsection{Overview (conceptual diagram)}\label{chap: Overview-External}

%figure conceptual DT
\begin{figure}[htb]
\includegraphics[width=\textwidth]{figures/DT_Conceptual_Diagram.pdf}

\centering
\caption{Conceptual diagram of MAS\label{fig: DTConceptual}}
\end{figure}

The workflow of updating global \gls{dt} through the \gls{dta} process is shown 
in Figure \ref{fig: DTConceptual}. The process begins on the left-hand side of the 
graph, where the \gls{dta} receives process data from robots, including steady-state 
data. The process data is parsed and uploaded one by one to the Azure \gls{dt} 
platform after separating the sticky packets from the \gls{tcp} socket.
All the updates of the \gls{dt} instances in the cloud are temporarily displayed 
in Azure \gls{dt} Explorer and concurrently stored in Azure Event Hubs. The history 
data can be ingested for further analysis in Azure Data Explorer. The Azure \gls{dt} 
Explorer serves as a robot status monitor, while Azure Data Explorer is a data analysis tool.
Once the remote data update is successful, the data is immediately downloaded to the local 
host and can be used as input for other visualization purposes. The real-time capability 
of this upload and download cycle of data should also be maintained.

It is important to note that the process data is generated by robot movement, 
which means that the \gls{dta} is completely independent of the \gls{mas}. This decoupling 
offers a 
significant advantage. Even if the \gls{mas} is in complete chaos, the robot's current status 
will still be captured and updated remotely. This is advantageous for both data acquisition 
and monitoring purposes.



\subsection{Prerequisite} \label{chap: ntpsetup}
\subsubsection{\gls{ntp} setup}
In order to measure the delays between the local host and cloud, the clock of both ends must be synchronized. 
Due to the nature of computer systems, the software clock might drift away from the "true" time (absolute \gls{utc}) 
due to various reasons like system load, hardware imperfections, or even temperature changes.
Therefore, before the measurement, the software clock of the local host should be synchronized with the global 
clock using \gls{ntp}. 
The \gls{ntp} setup of the Linux system is as follows:  

\begin{enumerate}
    \item System update and upgrade.
    \item Install \gls{ntp}.
    \item Add reliable global \gls{ntp} servers/server pools to configure ntp.conf file.
    \item Allow port 123/udp for or disable firewall.
    \item Restart \gls{ntp} and check \gls{ntp} status.
    \item Check synchronization status (e.g.: reach, delay, offset and jitter, etc).
    \end{enumerate}

Since the cloud system clock is already synchronized with \gls{utc}, all the tests and calculations results are based on \gls{utc}. 

\subsection{Data flow with \gls{tcp} socket and Azure \gls{dt} REST APIs}\label{chap: RCPTCP-DTAPI}
Differnt from the \gls{mas} with frequent connection reestablishment and heavy data handling in \gls{ca}, 
\gls{dta} only conducts a simple one-way data flow, starting from \gls{rcp} and 
ending at local download from Azure \gls{dt} platform. \gls{tcp} is beneficial for 
its less overhead and lightweight compared to WebSocket. 


The Azure \gls{dt} REST APIs are, on the other hand, responsible for the data 
transport between local devices and cloud. It consists of two modules, the 
control plane APIs for manages \gls{dt} instances as a whole, and the 
data plane APIs to mangage elements of the Azure \gls{dt} instances. For the 
time measurement of \gls{dt} update, we mainly used the data plane APIs. The 
common operations including create, delete, update, and list. In the test, two 
APIs are mainly used. \textit{UpdateDigitalTwin} for updating the whole twin instance 
and \textit{UpdateComponent} for the specific update of \gls{dt} component. 
Other APIs, for example, \textit{Query} is used to execute queries for twin 
instances, to get the demanding components. It was once used for timestamp 
logging in local device. 

\subsection{Pseudo-Code of \gls{rcp} and \gls{dta} workflow in C++ and C\#}\label{chap: RCPDTAPseudo}

As previously mentioned in this chapter, it is important to completely separate the 
\gls{dta} from the \gls{mas}. Algorithms \ref{alg:RCPPseudoCode} and 
\ref{alg:DTAgentPseudoCode} list the workflows of \gls{rcp} and \gls{dta} separately. 
In the \gls{rcp} workflow, the robot arm is controlled through predefined functions 
that can record the current states. Each new state recorded must be immediately sent 
to the \gls{dta} via the established \gls{tcp} socket. 
On the \gls{dta} side, it must be started before the \gls{rcp} and listen to the 
socket to receive the data stream once connected. Whenever a new connection to a 
\gls{ra} is established, the \gls{dta} will create a new thread to receive, process, 
upload and download data concurrently. 
However, an issue with using \gls{tcp} is that packets do not arrive individually 
but are stuck together. To solve this, delimiters are utilized for sticky packet separation.

%pseudo code for RCP
\begin{breakablealgorithm}
    \caption{Pseudo-Code of \gls{rcp} workflow}
    \label{alg:RCPPseudoCode}
    \begin{algorithmic}
    \State {Import} socket, franka
    \State {Initialize} \gls{dta}\_IP
    \State \textbf{function} {$get\_rstate\_and\_send(clientSocket)$}
        \State \qquad Start robot motion and record robot state
        \State \qquad {$send\_message(robotState, clientSocket)$}
    \State \textbf{function} {$send\_message(msg, clientSocket)$}
        \State \qquad send robot state to \gls{dta} 
    \State \textbf{Main:}
    \State \qquad Instantiate robot
    \State \qquad Initialize start position
    \State \qquad Establish a \gls{tcp} connection with \gls{dta}  
    \State \qquad {$get\_rstate\_and\_send(clientSocket)$}
    \State \textbf{End}
    \end{algorithmic}
\end{breakablealgorithm}


%pseudo code for DTAgent
\begin{breakablealgorithm}
    \caption{Pseudo-Code of \gls{dta} workflow}
    \label{alg:DTAgentPseudoCode}
    \begin{algorithmic}
    \State {Import} socket, AzureDigitalTwin
    \State {Initialize} \gls{rcp}\_IP(s)
    \State \textbf{function} {$read\_and\_upload\_download\_processData(\gls{rcp}\_IP)$}
        \State \qquad \textbf{do run in parallel}
            \State \qquad \qquad $create\_client\_thread(\gls{rcp}\_IP)$       
    \State \textbf{function} {$create\_client\_thread(\gls{rcp}\_IP)$}
        \State \qquad Establish a \gls{tcp} connection with \gls{ra}
        \State \qquad {$data = read\_data(clientSocket)$}  
        \State \qquad {$process\_data\_upload\_and\_download(data)$}    
    \State \textbf{function} {$read\_data(clientSocket)$}
        \State \qquad receive and store robot state data
        \State \qquad \textbf{return} data
    \State \textbf{function} {$process\_data\_upload\_and\_download(data)$}
        \State \qquad separate sticky packets with delimiter
        \State \qquad upload processed data to Azure \gls{dt} in json patch
        \State \qquad download twin after data update 
    \State \textbf{Main:}
        \State \qquad \textbf{for} \gls{rcp}\_IP in IPs \textbf{do}
        \State \qquad \qquad {$read\_and\_upload\_download\_processData(\gls{rcp}\_IP)$}
        \State \textbf{End}
    \end{algorithmic}
\end{breakablealgorithm}



\subsection{Azure \gls{dt}}
According to the workflow explained in section \ref{chap: Overview-External}, 
it is crucial to establish a reliable and operational Azure \gls{dt} platform 
to ensure seamless data transfer. The platform should include Azure \gls{dt} Explorer, 
Azure Event Hub, and Azure Data Explorer. Additionally, the Azure \gls{dt} 
instance must be configured with a time-series data history connection. Other resources 
must also be created, such as an Event Hubs namespace, an event hub, Azure Data Explorer 
cluster, and a database. To use the data update APIs 
from section \ref{chap: RCPTCP-DTAPI}, a client for Azure Digital Twins should be 
initialized. The correct steps should be: 


\begin{enumerate}
    \item Initialize the URL that points to the Azure \gls{dt}
    \item Get a credential to authenticate with Azure services
    \item Creat a client object that allows interaction between \gls{dta} and Azure \gls{dt}
    \end{enumerate}

After the connection from the local device to the Azure \gls{dt}, 
data is sent to an event hub, which eventually forwards the data to 
the Azure Data Explorer cluster and stores it in a database. The history data includes 
twin property updates, twin lifecycle events, and relationship lifecycle events, which 
can be later queried in Azure Data Explorer.

\subsubsection{Data history setup}
Here is the sequence of the basic setup in the Azure platform:
\begin{enumerate}
    \item Create Azure Event Hub namespace and add instance.
    \item Create Azure Data Explorer cluster and add database.
    \item Connect data history of the Event Hub instance to the \gls{dt} instance.
\end{enumerate}

In order to verify whether the connection is successful, one can try updating the 
\gls{dt} instance and querying data from the Azure Data Explorer side. The query
language is called \gls{kql}, which is powerful for pattern discovery, anomalies 
and outliers identification, and statistical modeling (various graphs creation). 
Following algorithm \ref{alg: KQLCode} is a snippet of the example \gls{kql} code in the test: 

\begin{algorithm}
    \caption{\gls{kql}}
    \label{alg: KQLCode}
    \begin{algorithmic}
        \State  AdtPropertyEvents 
        \State {| where ID == 'RadPositionJoint3' and Key == 'value'}
        \State {| where TimeStamp between (datetime(2023-08-27 16:02) .. datetime(2023-08-27 19:00))}
        \State {| order by TimeStamp asc}
        \State {| project TimeStamp, Id, Key, Value}
    \end{algorithmic}
\end{algorithm}


\begin{figure}[htb]
    \includegraphics[width=\textwidth]{figures/KQL_cut.jpg}
    
    \centering
    \caption{Snippet of Data Explorer\label{fig: KQL}}
\end{figure}

As shown in fig.\ref{fig: KQL}, by executing the code from the snippet, all the history data will be listed as a table 
which can be downloaded to the local devices later. 


\section{Modularization}\label{chap: Meth-Modular}
In addition to the internal and external designs of a general \gls{mas}, 
there are also some considerations of modularizing timing behaviors of the 
system. In the following sections, the \gls{tcp/ip} model as well as 
\gls{dsl} will be introduced and used as the design basis of a modularized general 
\gls{mas}. 
\subsection{From \gls{osi} model to \gls{tcp/ip} model}

Although TCP is classified as a transport layer protocol according to the 
OSI model (fig.\ref{fig: OSI}), data transport between different TCP sockets 
still involves all layers. This is because a program using socket libraries 
operates the TCP socket, which is an operation under the application layer. 
The transport layer protocols only accept data from the session layer in the 
OSI model and break it down into smaller pieces to ensure reliable and correct 
data transport. However, considering delays in all seven layers for modularization 
purposes would be too strict and complicated. Therefore, the focus should be 
shifted from the general OSI model to the more abstract TCP/IP model, as depicted 
in fig.\ref{fig: TCP_IP}.

The TCP/IP model consists of four layers: application layer, transport layer, 
internet layer, and network access layer, with each mapping different layers in 
the OSI model. As depicted in the TCP/IP model, the application layer roughly 
contains the upper three layers, while the network access layer contains the 
physical and data link layer. The network layer is renamed as the internet 
layer, while the transport layer remains the same.

\begin{figure}[htb]
    \includegraphics[width=\textwidth]{figures/TCP_IP.pdf}
    
    \centering
    \caption{\gls{tcp/ip} model with example protocols \label{fig: TCP_IP}}
\end{figure}

\subsection{Timing properties of data transport w.r.t sockets and visual notations based on \gls{tcp/ip} model}
When operating in an application, both TCP sockets and WebSockets transport packets 
through all layers of the TCP/IP model. In order to better modularize delay, a set of 
visual notations based on \gls{dsl} is created.
Thanks to the works of former researchers, there are already some graphical tools 
developed for different purposes. The graphical tools 
can be roughly divided into two types: tools ideal for real-world delay measurement, 
for example, the famous Wireshark, OPNET, and NS-3, 
and tools suitable for modeling and visualization, such as OpenModelica, 
Matlab/Simulink and LabVIEW.



Although being out of the scope of this thesis, the measurement of delay within 
each layer of \gls{tcp/ip} model will be essential for future investment.
For instance, as depicted in fig.\ref{fig: DSLConceptual}, the delay in 
each layer is represented as a block based on \gls{dsl}, which can be later integrated 
with graphical tools.
In this case, delay in a specific network layer will become comparable between different 
technologies based on either application or transport layer protocols, for example, 
\gls{tcp} socket and WebSocket. Apart from the network delay of communication between 
agents, as shown in the fig.\ref{fig: DSLConceptual}, there is also another delay that can be modularized in 
the context of robot control. The robot control systems introduce delay first in \gls{rci} 
by executing the commands and then a minor delay within the I/O module before activating 
the actuator.
After each robot motion driven by the actuator, its current state will be sent back to 
the \gls{cpu} by first going through the sensor, I/O module, and \gls{rci} again. 







\begin{figure}[htb]
    \includegraphics[width=\textwidth]{figures/DSLConceptual.pdf}
    
    \centering
    \caption{Conceptual diagram of a modularized general \gls{mas} based on \gls{dsl} \label{fig: DSLConceptual}}
\end{figure}
